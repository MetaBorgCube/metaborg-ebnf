module inline

imports

  signatures/TemplateLang-sig

strategies

  simplify = bottomup(try(rename))
  inline-sorts = oncetd(inline)
  
rules

  inline: l -> f
    where
      // Get a list of definitions only used once
      i := <get-single-used-sorts> l
      // Get definitions which are in the list
    ; d := <get-definitions; hashtable-getlist> (i, l)
      // Substitute in the place they're used
    ; s := <substitute-definitions> (d, l)
      // Only remove definitions which were found for substitution
    ; f := <remove-definitions> (<hashtable-keys> d, s)
    
rules
  
  get-single-used-sorts: l -> i
    with
    s := <map(filter-sort); concat; map(get-sort-name); string-sort> l
    ; i := <count-list; debug; hashtable-getlist; debug; filter(count-filter); debug; map(Fst); debug> (<new-hashtable>, s)
    
  // Get list of sorts from the rules
  filter-sort: SdfProductionWithCons(_, Rhs(r), _) -> <map(get-sort); flatten-list> r

  get-sort: Sort(i) -> Sort(i)
  get-sort: Iter(Sort(i)) -> Sort(i)
  get-sort: IterStar(Sort(i)) -> Sort(i)
  get-sort: IterSep(Sort(i), _) -> Sort(i)
  get-sort: IterStarSep(Sort(i), _) -> Sort(i)
  get-sort: Lit(_) -> []
  get-sort: Opt(_) -> []

  get-sort-name: Sort(i) -> i
    
  // Apply the count method to every element in the list
  count-list: (tbl, []) -> tbl
  count-list: (tbl, [a|t]) -> tbl2
    with
      tbl1 := <count> (tbl, a)
    ; tbl2 := <count-list> (tbl1, t)

  // Try to increment the value in the table, if not create the counter
  count: (tbl, i) -> tbl2
    where
      k := <hashtable-get(|i)> tbl
    ; n := <add> (k, 1)
    ; tbl2 := <hashtable-put(|i, n)> tbl
  count: (tbl, i) -> tbl2
    where
      tbl2 := <hashtable-put(|i, 1)> tbl
      
  count-filter: (s, 1) -> (s, 1)
  
rules

  get-definitions: (d, l) -> <get-defs> (<new-hashtable>, d, l)
      
  get-defs: (h, [], l) -> h
  get-defs: (h, [d|t], l) -> <get-defs> (h1, t, l)
    where
      rhs := <filter(is-definition(|d)); index(|1); get-definition> l
    ; h1 := <hashtable-put(|d, rhs)> h
      
  // Check whether this is the definition we're looking for
  is-definition(|a): SdfProductionWithCons(SortCons(SortDef(a), c), r, atr) -> SdfProductionWithCons(SortCons(SortDef(a), c), r, atr)
  // Get the definition of the rule
  get-definition: SdfProductionWithCons(_, r, _) -> r
  
  contains(|a): [] -> 0
  contains(|a): [a|t] -> 1
  contains(|a): [b|t] -> <contains(|a)> t
  
rules

  substitute-definitions: ([], l) -> l
  substitute-definitions: ([(n, rhs)|t], l) -> <substitute-definitions> (t, l1)
    where
      l1 := <substitute-definition(|n, rhs)> l

  // Substitute the right hand sides with the definition given in the strategy
  substitute-definition(|n, r): [SdfProductionWithCons(SortCons(SortDef(s), c), Rhs([Sort(n)]), atr)|t] -> res
    where
      res := [SdfProductionWithCons(SortCons(SortDef(s), Constructor(n)), r, atr)|t]
  substitute-definition(|n, r): [h|t] -> [h|<substitute-definition(|n, r)> t]

rules

  // Removes all definitions in the first list from the sdf definitions in the second list
  remove-definitions: ([], l) -> l
  remove-definitions: ([d|t], l) -> <remove-definitions> (t, l1)
    where
      l1 := <remove-all(is-definition(|d))> l
      
rules

  rename: SdfProductionWithCons(
            SortCons(s, c)
          , Rhs([Sort(i)])
          , NoAttrs()
          ) -> SdfProductionWithCons(
            SortCons(s, Constructor(i))
          , Rhs([Sort(i)])
          , NoAttrs()
          )